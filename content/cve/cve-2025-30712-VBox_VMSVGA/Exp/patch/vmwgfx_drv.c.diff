--- linux-source-6.8.0/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.bk	2025-11-07 13:10:17.413669707 +0000
+++ linux-source-6.8.0/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c	2025-11-07 03:07:33.641001104 +0000
@@ -161,6 +161,243 @@
 	DRM_IOW(DRM_COMMAND_BASE + DRM_VMW_MKSSTAT_REMOVE,	\
 		struct drm_vmw_mksstat_remove_arg)
 
+/* ----------------------------------------------
+ * 
+ * Research modifications
+ *
+ */
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h> /* register_chrdev, unregister_chrdev */
+#include <linux/seq_file.h> /* single_open, single_release, seq_printf */
+#include <linux/dma-mapping.h> /* dma_alloc_coherent */
+
+#define NAME "vgapwn"
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static struct vmw_private *dev_ref = NULL;
+
+static int show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "[+] open vgapwn_dev.");
+	return 0;
+}
+
+static int vgapwn_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, show, NULL);
+}
+
+static void vgapwn_cleanup(int device_created)
+{
+	if (device_created) {
+		device_destroy(myclass, major);
+		cdev_del(&mycdev);
+	}
+	if (myclass)
+		class_destroy(myclass);
+	if (major != -1)
+		unregister_chrdev_region(major, 1);
+}
+
+static ssize_t vgapwn_write(struct file *f, const char __user *buf, size_t size, loff_t *offset) {
+	if (size == 0)
+		return -EINVAL;
+
+	printk(KERN_INFO "vgapwn_write start\n");
+
+	u8 *cmd = VMW_CMD_RESERVE(dev_ref, size);
+	if (unlikely(cmd == NULL))
+		return -ENOMEM;
+
+	if (copy_from_user(cmd, buf, size)) 
+		return -EINVAL;
+	
+	vmw_cmd_commit_flush(dev_ref, size);
+	printk(KERN_INFO "vgapwn_write done\n");
+
+	return 0;
+}
+
+typedef struct vgapwn_dma_alloc {
+    uint64_t size;
+    uint64_t virt_addr;
+    uint64_t phys_addr;
+} vgapwn_dma_alloc_t;
+
+typedef struct vgapwn_read {
+    uint64_t size;
+    uint64_t src; // kernel virt_addr
+    uint64_t dst; // user   buf_addr
+} vgapwn_read_t;
+
+typedef struct vgapwn_write {
+    uint64_t size;
+    uint64_t src; // user   buf_addr
+    uint64_t dst; // kernel virt_addr
+} vgapwn_write_t;
+
+typedef struct vgapwn_dma_free {
+    uint64_t size;
+    uint64_t virt_addr;
+    uint64_t phys_addr;
+} vgapwn_dma_free_t;
+
+typedef struct vgapwn_run_cmd {
+    uint8_t *buf;
+    uint64_t size;
+} vgapwn_run_cmd_t;
+
+#define VGAPWN_IOCTL_MAGIC	'k'
+#define VGAPWN_DMA_ALLOC	_IOWR(VGAPWN_IOCTL_MAGIC, 0, vgapwn_dma_alloc_t)
+#define VGAPWN_DMA_READ		_IOWR(VGAPWN_IOCTL_MAGIC, 1, vgapwn_read_t)
+#define VGAPWN_DMA_WRITE	_IOW(VGAPWN_IOCTL_MAGIC, 2, vgapwn_write_t)
+#define VGAPWN_DMA_FREE		_IOW(VGAPWN_IOCTL_MAGIC, 3, vgapwn_dma_free_t)
+#define VGAPWN_RUN_CMD		_IOW(VGAPWN_IOCTL_MAGIC, 4, vgapwn_run_cmd_t)
+
+static long vgapwn_ioctl(struct file *f, unsigned int cmd, long unsigned int buf) {
+	//printk(KERN_INFO "vgapwn_ioctl: cmd %d", cmd);
+    if (_IOC_TYPE(cmd) != VGAPWN_IOCTL_MAGIC) {
+        printk(KERN_ERR "vgapwn_ioctl: wrong magic number: %c\n", _IOC_TYPE(cmd));
+        return -ENOTTY;
+    }
+    
+	switch (cmd) {
+		case VGAPWN_DMA_ALLOC:
+		{
+			vgapwn_dma_alloc_t args;
+			dma_addr_t dma_handle;
+			void *dma_buffer = NULL;
+
+			if (copy_from_user(&args, (vgapwn_dma_alloc_t __user *)buf, sizeof(vgapwn_dma_alloc_t))) {
+				return -EFAULT;
+			}
+			dma_buffer = (void *)__get_free_pages(GFP_KERNEL, get_order(args.size));
+			if (dma_buffer) {
+				memset(dma_buffer, 0, args.size);
+				dma_handle = virt_to_phys(dma_buffer);
+			}
+			args.virt_addr = (uint64_t)dma_buffer;
+			args.phys_addr = (uint64_t)dma_handle;
+			printk(KERN_INFO "DMA buffer: virt=%#llx, phys=%#llx\n", 
+				 args.virt_addr, args.phys_addr);
+
+			if (copy_to_user((uint8_t __user *)buf, &args, sizeof(args))) {
+				return -EFAULT;
+			}
+			printk(KERN_INFO "vgapwn_ioctl: VGAPWN_DMA_ALLOC done.\n");
+			break;
+		}
+		case VGAPWN_DMA_READ:
+		{
+			vgapwn_read_t args;
+
+			if (copy_from_user(&args, (vgapwn_read_t __user *)buf, sizeof(vgapwn_read_t))) {
+				return -EFAULT;
+			}
+			if (copy_to_user((uint8_t __user *)args.dst, (uint8_t *)args.src, args.size)) {
+				return -EFAULT;
+			}
+			printk(KERN_INFO "vgapwn_ioctl: VGAPWN_DMA_READ done.\n");
+			break;
+		}
+		case VGAPWN_DMA_WRITE:
+		{
+			vgapwn_write_t args;
+			int rc = 0;
+
+			rc = copy_from_user(&args, (vgapwn_write_t __user *)buf, sizeof(vgapwn_write_t));
+			if (rc) {
+				printk(KERN_ERR "vgapwn_ioctl: VGAPWN_DMA_WRITE copy_from_user1 rc=%d faild.\n", rc);
+				return -EFAULT;
+			}
+			printk(KERN_INFO "VGAPWN_DMA_WRITE: src=%#llx, dst=%#llx, size=%#llx",
+				args.src, args.dst, args.size);
+
+			rc = copy_from_user((uint8_t *)args.dst, (uint8_t __user *)args.src, args.size);
+			if (rc) {
+				printk(KERN_ERR "vgapwn_ioctl: VGAPWN_DMA_WRITE copy_from_user2 rc=%d faild.\n", rc);
+				return -EFAULT;
+			}
+			printk(KERN_INFO "vgapwn_ioctl: VGAPWN_DMA_WRITE done.\n");
+			break;
+		}
+		case VGAPWN_DMA_FREE:
+		{
+			vgapwn_dma_free_t args;
+
+			if (copy_from_user(&args, (vgapwn_dma_free_t __user *)buf, sizeof(vgapwn_dma_free_t))) {
+				return -EFAULT;
+			}
+			free_pages(args.virt_addr, get_order(args.size));
+			printk(KERN_INFO "vgapwn_ioctl: VGAPWN_DMA_FREE done.\n");
+			break;
+		}
+		case VGAPWN_RUN_CMD:
+		{
+			vgapwn_run_cmd_t args;
+			if (copy_from_user(&args, (vgapwn_run_cmd_t __user *)buf, sizeof(vgapwn_run_cmd_t))) {
+				return -EFAULT;
+			}
+
+			u8 *cmd = VMW_CMD_RESERVE(dev_ref, args.size);
+			if (unlikely(cmd == NULL))
+				return -ENOMEM;
+
+			if (copy_from_user(cmd, args.buf, args.size)) 
+				return -EINVAL;
+			
+			vmw_cmd_commit_flush(dev_ref, args.size);
+			printk(KERN_INFO "vgapwn_ioctl: VGAPWN_RUN_CMD done.\n");
+			break;
+		}
+		default:
+			printk(KERN_ERR "Unknown ioctl command.\n");
+			return -ENOTTY;
+	}
+
+	return 0;
+}
+
+static const struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.open = vgapwn_open,
+	.write = vgapwn_write,
+	.unlocked_ioctl = vgapwn_ioctl,
+	.release = single_release,
+};
+
+static int vgapwn_init(struct vmw_private *dev_priv)
+{
+	dev_ref = dev_priv;
+	int device_created = 0;
+
+	/* cat /proc/devices */
+	if (alloc_chrdev_region(&major, 0, 1, NAME "_proc") < 0)
+		goto error;
+	/* ls /sys/class */
+	if ((myclass = class_create(NAME "_sys")) == NULL)
+		goto error;
+	/* ls /dev/ */
+	if (device_create(myclass, NULL, major, NULL, NAME "_dev") == NULL)
+		goto error;
+	device_created = 1;
+	cdev_init(&mycdev, &fops);
+	if (cdev_add(&mycdev, major, 1) == -1)
+		goto error;
+	return 0;
+error:
+	vgapwn_cleanup(device_created);
+	return -1;
+}
+
+/* ----------------------------------------------
+ * Modifications end
+ *
+ */
+
 /*
  * Ioctl definitions.
  */
@@ -858,6 +1095,8 @@ static int vmw_driver_load(struct vmw_pr
 
 	vmw_sw_context_init(dev_priv);
 
+	vgapwn_init(dev_priv);
+
 	mutex_init(&dev_priv->cmdbuf_mutex);
 	mutex_init(&dev_priv->binding_mutex);
 	spin_lock_init(&dev_priv->resource_lock);
@@ -1179,6 +1418,8 @@ static void vmw_driver_unload(struct drm
 	struct pci_dev *pdev = to_pci_dev(dev->dev);
 	enum vmw_res_type i;
 
+	vgapwn_cleanup(1);
+
 	unregister_pm_notifier(&dev_priv->pm_nb);
 
 	vmw_sw_context_fini(dev_priv);
